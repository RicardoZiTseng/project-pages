---
layout: post
author: Ricardo
title: pat踩坑记(1)
subtitle: 1001(采花生) 1002(NowCoder数列) 1003(养兔子)
tags: C C++ pat
---

今天开始刷pat习题，刚刷上就踩了很多坑==！

- 输入数据

  完成输入数据最好用这条语句

  ```c++
  while(scanf("%d", &n) != EOF){
    ...
  }
  ```

- 采花生

  > **题目描述**：
  >
  > ```
  > 鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！——熊字”。
  >
  > 鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说:“你先找出花生最多的植株，去采摘它的花生;然后再找出剩下的植株里花生最多的，去采摘它的花生;依此类推，不过你一定要在我限定的时间内回到路边。”
  >
  > 我们假定多多在每个单位时间内,可以做下列四件事情中的一件：
  >
  > 1. 从路边跳到最靠近路边（即第一行）的某棵花生植株；
  > 2. 从一棵植株跳到前后左右与之相邻的另一棵植株；
  > 3. 采摘一棵植株下的花生；
  > 4. 从最靠近路边（即第一行）的某棵花生植株跳回路边。
  >
  > 现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？
  >
  > 注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。例如花生田里只有位于(2, 5), (3, 7), (4, 2), (5, 4)的植株下长有花生，个数分别为 13, 7, 15, 9。多多在 21 个单位时间内，只能经过(4, 2)、(2, 5)、(5, 4)，最多可以采到 37 个花生。
  > ```
  >
  > 输入描述：
  >
  > ```
  > 输入包含多组数据，每组数据第一行包括三个整数 M（1≤M≤20）、N（1≤N≤20）和 K（0≤K≤1000），用空格隔开；表示花生田的大小为 M * N，多多采花生的限定时间为 K个单位时间。
  >
  > 紧接着 M 行，每行包括 N 个自然数 P（0≤P≤500），用空格隔开；表示花生田里植株下花生的数目，并且除了0（没有花生），其他所有植株下花生的数目都不相同。
  > ```
  >
  > 输出描述：
  >
  > ```
  > 对应每一组数据，输出一个整数，即在限定时间内，多多最多可以采到花生的个数。
  > ```
  >
  > 输入例子：
  >
  > ```
  > 6 7 21
  > 0 0 0 0 0 0 0
  > 0 0 0 0 13 0 0
  > 0 0 0 0 0 0 7
  > 0 15 0 0 0 0 0
  > 0 0 0 9 0 0 0
  > 0 0 0 0 0 0 0
  > ```

  这道题最重要的是理解题目意思，一开始没有弄懂题目的意思，具体在这几个疑问下：

  1.路边跳到第一行的时候，可以跳到第一行的任意位置

  2.需要尽可能地找到花生数最多的植株然后采集

  3.将二维数组改成一维数组来查找

  源代码：

  ```c++
  #include <cstdio>
  #include <cstring>
  #include <algorithm>
  #include <cmath>
  using namespace std;

  const int maxn = 20;

  struct Peanut{
    int x;
    int y;
    int num;
  }pool[400];

  bool compare(Peanut m1, Peanut m2){
    return m1.num > m2.num;
  }

  int main(){
    int M, N, K;
    
    while(scanf("%d %d %d", &M, &N, &K)!=EOF){
      int count = 0, ans = 0, time = 0;
      memset(pool, 0, 400);
      for(int i=1;i<=M;i++){
        for(int j=1;j<=N;j++){
          int A;
          scanf("%d", &A);
          if(A){
            pool[count] = i;
            pool[count] = j;
            pool[count++] = A;
          }
        }
      }
      sort(pool, pool+count, compare);
      time = pool[0].x + 1;
      if(time + pool[0].x <= K)
        ans += pool[0].num;
      int now = 0;
      for(int i=1;i<count;i++){
        int temp = abs(pool[now].x - pool[i].x) + abs(pool[now].y - pool[i].y) + 1;
     	  if(time + temp + pool[i].x <= K){
          time += temp;
          ans += pool[i].num;
          now = i;
     	  }else{
          break;
     	  }
      }
      printf("%d\n", ans);
    }
    return 0;
  }
  ```

- NowCoder数列

  > ```
  > NowCoder最近在研究一个数列：
  >
  > * F(0) = 7
  > * F(1) = 11
  > * F(n) = F(n-1) + F(n-2) (n≥2)
  >
  > 他称之为NowCoder数列。请你帮忙确认一下数列中第n个数是否是3的倍数。(0≤n≤1000000)
  > ```

  这道题初看像是一道fibonacii数列的题目,很容易入坑直接去算这些数，但要注意n的取值范围，无论是int还是long亦或是long long都无法满足这些数，所以题目暗示我们要去找这些数的规律。研究发现，从第3个数开始，每隔四个就是3的倍数。

- 养兔子

  > ```
  > 一只成熟的兔子每天能产下一胎兔子。每只小兔子的成熟期是一天。 某人领养了一只小兔子，请问第N天以后，他将会得到多少只兔子。(1≤n≤90)
  > ```

  这道题分析之后还是数列的问题，而且要注意到n的值不大，因此题目暗示我们需要求出具体数值，但是int肯定不满足，最好用long long型来处理数据。

  入坑原因是什么都没想开始搞动态模拟==我的天23333 写了很复杂的代码，一定要警戒！