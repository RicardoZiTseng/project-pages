---
layout: post
title: c语言内存中的堆与栈学习笔记
author: Ricardo
tags: C
---

一般情况下，程序放在Rom(只读内存，比如硬盘)，运行时拷贝到RAM中执行，在RAM中会存储不同的信息，如下图所示：

![](http://pic002.cnblogs.com/images/2012/47975/2012031416390882.jpg)

- 栈地址是向下生长的，而堆区是向上增长的。
- 栈中分配局部变量
- 堆中分配程序员申请的内存空间
- 静态区分配静态变量和全局变量
- 只读区分配常量和程序代码

> ```c++
> int a = 0;  //全局初始化区
> char *p1;  //全局未初始化区
> main()
>   {
>     int b;  //栈区
>   	char s[] = "abc";  //栈区
>   	char *p2; //栈区
>   	char *p3 = "123456";  //"123456"在常量区，而p3在栈区
>   	static int c = 0;  //全局(静态)初始化区
>   	p4 = (char *)malloc(sizeof(char)*10);  //堆
>   }
> ```



#### 堆与栈的区别

- 申请方式与回收方式不同

  > 栈是由系统自动分配内存空间的，如:
  >
  > ```c
  > char a;
  > ```
  >
  > 系统自动在栈上为a开辟空间。
  >
  > 而堆是由程序员自己申请并管理空间，如：
  >
  > ```c
  > int *a = (int *)malloc(sizeof(int));
  > free(a);
  > ```
  >
  > 栈上的数据的生存周期只是在函数的运行过程中，运行完毕就被系统自动释放掉，不能够再被访问。而堆上的数据只要程序员不释放空间，就会一直存在并访问到。

- 申请后系统的响应

  > 栈：只要申请的空间小于栈的剩余空间，系统将继续为程序提供内存，否则将报告栈溢出。
  >
  > 堆：操作系统有一个记录空闲内存地址的链表，当系统受到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从链表上删除，并将该结点的空间分配给程序。由于大多数找到的堆结点的空间大于申请到的空间大小，因此系统会将多余的部分重新放回空闲链表中。申请完毕后，操作系统会在申请空间的首地址处记录所分配的空间大小，方便``delete``语句释放内存，
  >
  > **我们可以看出，堆在申请后会引发一系列操作，因此堆上的内存空间的申请会有申请效率的问题。**

- 申请效率的比较

  > 栈：由系统自动分配，申请速度较快
  >
  > 堆：由程序员申请分配内存，速度较慢，容易产生内存碎片

- 申请大小的限制

  > 栈：在windows下，栈是向下扩展的数据结构，是一片连续的内存区域，也就是说栈的大小是系统预先设定好的，windows下的栈大小是2M，一旦溢栈，将会提示overflow
  >
  > 堆：向上扩展的数据结构，内存区域不连续，由链表存储空闲内存地址。堆的大小受限于操作系统的虚拟内存，可使用空间灵活且大

- 堆和栈中的存储内容

  > 栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 
  > 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
  >
  > 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。